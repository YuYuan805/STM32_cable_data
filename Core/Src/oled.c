#include "oled.h"
#include "delay.h"
#include "oledfont.h"
#include "spi.h"
#include "stdio.h"
#include "stdlib.h"
#include "stm32h7xx.h"
#include "string.h"
uint8_t OLED_GRAM[128][8];

// ???????OLED
void OLED_Refresh_Gram(void)
{
    uint8_t i, n;
    for (i = 0; i < 8; i++)
    {
        OLED_Write(0xb0 + i, OLED_CMD); // ??????????0~7??
        OLED_Write(0x00, OLED_CMD);     // ???????λ?á??е???
        OLED_Write(0x10, OLED_CMD);     // ???????λ?á??и???
        for (n = 0; n < 128; n++)
            OLED_Write(OLED_GRAM[n][i], OLED_DATA);
    }
}

// д?????????

// BSRR???????
// BRR???????
void OLED_Write(uint8_t Data, uint8_t Cmd)
{
    if (Cmd)
    {
        HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, 1);
        HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, 0);
        HAL_SPI_Transmit(&hspi1, &Data, 1, 1000);
        HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, 1);
    }
    else
    {
        HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, 0);
        HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, 0);
        HAL_SPI_Transmit(&hspi1, &Data, 1, 1000);
        HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, 1);
    }
}
// ????OLED???
void OLED_Display_On(void)
{
    OLED_Write(0X8D, OLED_CMD); // SET DCDC????
    OLED_Write(0X14, OLED_CMD); // DCDC ON
    OLED_Write(0XAF, OLED_CMD); // DISPLAY ON
}

// ???OLED???
void OLED_Display_Off(void)
{
    OLED_Write(0X8D, OLED_CMD); // SET DCDC????
    OLED_Write(0X10, OLED_CMD); // DCDC OFF
    OLED_Write(0XAE, OLED_CMD); // DISPLAY OFF
}

// ???OLED_GRAM??????е?????
void OLED_Clear(void)
{
    memset(OLED_GRAM, 0, sizeof(OLED_GRAM));
    OLED_Refresh_Gram();
}

void OLED_On(void)
{
    uint8_t i, n;
    for (i = 0; i < 8; i++)
    {
        OLED_Write(0xb0 + i, OLED_CMD); // ??????????0~7??
        OLED_Write(0x00, OLED_CMD);     // ???????λ?á??е???
        OLED_Write(0x10, OLED_CMD);     // ???????λ?á??и???
        for (n = 0; n < 128; n++)
            OLED_Write(1, OLED_DATA);
    } // ???????
}

// ??????
// x:0~110
// y:0~52
// ??X Y????110 52??????????????????????????
// t:1 ??? 0,???
// ???????????
void OLED_DrawPoint(uint8_t x, uint8_t y, uint8_t t)
{
    uint8_t pos, bx, temp = 0;
    if (x > 127 || y > 63)
        return; // ??????Χ??.
    pos = 7 - y / 8;
    bx = y % 8;
    temp = 1 << (7 - bx);
    if (t)
        OLED_GRAM[x][pos] |= temp;
    else
        OLED_GRAM[x][pos] &= ~temp;
}

// x1,y1,x2,y2 ??????????????
// ???x1<=x2;y1<=y2 0<=x1<=127 0<=y1<=63
// dot:0,???;1,???

// ?????

void OLED_Fill(uint8_t Fill_Data)
{
    uint8_t m, n;
    for (m = 0; m < 8; m++)
    {
        OLED_Write(0xb0 + m, 0); // page0-page1
        OLED_Write(0x00, 0);     // low column start address
        OLED_Write(0x10, 0);     // high column start address
        for (n = 0; n < 128; n++)
        {
            OLED_Write(Fill_Data, 1); // ???????
        }
    }
}
// ?????λ???????????,???????????
// x:0~110
// y:0~52
// ??X Y????110 52??????????????????????????
// mode:0,???????;1,???????
// size:??????? 12/16/24
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t size, uint8_t mode)
{
    uint8_t temp = 0, t = 0, t1 = 0;
    uint8_t y0 = y;
    uint8_t csize = (size / 8 + ((size % 8) ? 1 : 0)) * (size / 2); // ??????????????????????????????
    chr = chr - ' ';                                                // ?????????
    for (t = 0; t < csize; t++)
    {
        if (size == 12)
            temp = asc2_1206[chr][t]; // ????1206????
        else if (size == 16)
            temp = asc2_1608[chr][t]; // ????1608????
        else
            return; // ??е????
        for (t1 = 0; t1 < 8; t1++)
        {
            if (temp & 0x80)
                OLED_DrawPoint(x, y, mode);
            else
                OLED_DrawPoint(x, y, !mode);
            temp <<= 1;
            y++;
            if ((y - y0) == size)
            {
                y = y0;
                x++;
                break;
            }
        }
    }
    OLED_Refresh_Gram(); // ?????????OLED??????????????????????
}

// m^n?η?????
uint32_t mypow(uint8_t m, uint8_t n)
{
    uint32_t result = 1;
    while (n--)
        result *= m;
    return result;
}
// ??????????
// x,y :???????
// x:0~110
// y:0~52
// ??X Y????110 52??????????????????????????
// len :?????λ??
// size:?????С
// mode:??	0,?????;1,??????
// num:???(0~4294967295);
void OLED_ShowNum(uint8_t x, uint8_t y, uint32_t num, uint8_t len, uint8_t size)
{
    uint8_t t, temp;
    uint8_t enshow = 0;
    for (t = 0; t < len; t++)
    {
        temp = (num / mypow(10, len - t - 1)) % 10;
        if (enshow == 0 && t < (len - 1))
        {
            if (temp == 0)
            {
                OLED_ShowChar(x + (size / 2) * t, y, ' ', size, 1);
                continue;
            }
            else
                enshow = 1;
        }
        OLED_ShowChar(x + (size / 2) * t, y, temp + '0', size, 1);
        OLED_Refresh_Gram(); // ?????????OLED??????????????????????
    }
}
// ????????
// x,y:???????
// x:0~110
// y:0~52
// ??X Y????110 52??????????????????????????
// size:?????С
//*p:???????????
// void OLED_ShowString(uint8_t x,uint8_t y,const uint8_t *p,uint8_t size)
//{
//     while((*p<='~')&&(*p>=' '))//?ж???????????!
//     {
//         if(x>(128-(size/2))){x=0;y+=size;}
//         if(y>(64-size)){y=x=0;OLED_Clear();}
//         OLED_ShowChar(x,y,*p,size,1);
//         x+=size/2;
//         p++;
//     }
//			OLED_Refresh_Gram();//?????????OLED??????????????????????

//
//}

// OLED?????????????
void OLED_Init(void)
{

    // OLED  DC RES CS??????
    // 8  ????/????
    // 9  CS??
    // 10  RES??λ

    // OLED??λ
    delay_ms(20);
    HAL_GPIO_WritePin(OLED_RES_GPIO_Port, OLED_RES_Pin, 1);
    delay_ms(10);
    HAL_GPIO_WritePin(OLED_RES_GPIO_Port, OLED_RES_Pin, 0);
    delay_ms(10);
    HAL_GPIO_WritePin(OLED_RES_GPIO_Port, OLED_RES_Pin, 1);
    // ????OLED????

    OLED_Write(0xAE, OLED_CMD); // ??????
    OLED_Write(0xD5, OLED_CMD); // ?????????????,?????
    OLED_Write(0x80, OLED_CMD); //[3:0],???????;[7:4],?????
    OLED_Write(0xA8, OLED_CMD); // ???????????
    OLED_Write(0X3F, OLED_CMD); // ???0X3F(1/64)
    OLED_Write(0xD3, OLED_CMD); // ??????????
    OLED_Write(0X00, OLED_CMD); // ????0
    OLED_Write(0x40, OLED_CMD); // ???????????? [5:0],????.
    OLED_Write(0x8D, OLED_CMD); // ????????
    OLED_Write(0x14, OLED_CMD); // bit2??????/???
    OLED_Write(0x20, OLED_CMD); // ???????????
    OLED_Write(0x02, OLED_CMD); //[1:0],00???е????;01???е????;10,??????;???10;
    OLED_Write(0xA1, OLED_CMD); // ???????????,bit0:0,0->0;1,0->127;
    OLED_Write(0xC0, OLED_CMD); // ????COM??跽??;bit3:0,?????;1,??????? COM[N-1]->COM0;N:???????
    OLED_Write(0xDA, OLED_CMD); // ????COM???????????
    OLED_Write(0x12, OLED_CMD); //[5:4]????
    OLED_Write(0x81, OLED_CMD); // ????????
    OLED_Write(0xEF, OLED_CMD); // 1~255;???0X7F (????????,??????)
    OLED_Write(0xD9, OLED_CMD); // ????????????
    OLED_Write(0xf1, OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2;
    OLED_Write(0xDB, OLED_CMD); // ????VCOMH ???????
    OLED_Write(0x30, OLED_CMD); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;
    OLED_Write(0xA4, OLED_CMD); // ??????????;bit0:1,????;0,???;(????/????)
    OLED_Write(0xA6, OLED_CMD); // ??????????;bit0:1,???????;0,???????
    OLED_Clear();
    OLED_Write(0xAF, OLED_CMD); // ???????
}

// ???ASCII?????
// x,y:???????
// x:0~110
// y:0~52
// ??X Y????110 52??????????????????????????
// size:?????С
//*p:???????????
void OLED_ShowString(uint8_t x, uint8_t y, const uint8_t *p, uint8_t size)
{
    while ((*p <= '~') && (*p >= ' ')) // ?ж???????????!
    {
        if (x > 128)
        {
            x = 0;
            y += size;
        }

        if (y > 64)
        {
            y = x = 0;
        }

        OLED_ShowChar(x, y, *p, size, 1);
        x += size / 2;
        p++;
    }

    OLED_Refresh_Gram(); // ?????????OLED??????????????????????
}

// ??????????????
// x,y:???????
// x:0~128
// y:0~64
// ??X Y????128 64??????????????????????
// size:?????С
// mode??1 ???????     0 ??????
//*p:?????????

#ifdef THE_ERROR_CODE
void OLED_ShowChinese(uint8_t x, uint8_t y, char *ch, uint8_t size, uint8_t mode)
{
    uint8_t temp, t, t1;
    uint16_t y0 = y;
    uint8_t *dzk;
    uint8_t index = 0;

    char *p = strstr(DiscoverChinese, ch);

    if (p != NULL)
    {
        index = ((p - DiscoverChinese) / 3);
        // OLED_ShowNum(10, 40, index, 5, 16);
        uint8_t csize = (size / 8 + ((size % 8) ? 1 : 0)) * size; // ???24*24?????72???

        if (size == 16)
            dzk = (uint8_t *)Chinese_1616[index]; // ?????????????????

        for (t = 0; t < csize; t++)
        {
            temp = dzk[t]; // ???????????

            for (t1 = 0; t1 < 8; t1++) // ??????λ????λ??????
            {
                if (temp & 0x80)
                    OLED_DrawPoint(x, y, mode);
                else
                    OLED_DrawPoint(x, y, !mode);

                temp <<= 1;
                y++;

                if ((y - y0) == size) // ??y??????????y?????????????24???????x?????1
                {
                    y = y0;
                    x++;
                    break;
                }
            }
        }

        OLED_Refresh_Gram(); // ?????????OLED??????????????????????
    }
}
#endif

void OLED_ShowChinese(uint8_t x, uint8_t y, const char *ch, uint8_t size, uint8_t mode)
{
    uint8_t temp, t, t1;
    uint16_t y0 = y;
    uint8_t *dzk;
    uint8_t index = 0;
    char *p = strstr(DiscoverChinese, ch);

    if (p != NULL)
    {
        index = ((p - DiscoverChinese) / 3);
        uint8_t csize = (size / 8 + ((size % 8) ? 1 : 0)) * size;

        if (size == 16)
            dzk = (uint8_t *)Chinese_1616[index];
        else
            return;

        for (t = 0; t < csize; t++)
        {
            temp = dzk[t];

            for (t1 = 0; t1 < 8; t1++)
            {
                if (temp & 0x80)
                    OLED_DrawPoint(x, y, mode);
                else
                    OLED_DrawPoint(x, y, !mode);

                temp <<= 1;
                y++;

                if ((y - y0) == size)
                {
                    y = y0;
                    x++;
                    break;
                }
            }
        }
        OLED_Refresh_Gram();
    }
}

// ?????????????
// x,y:???????
// x:0~128
// y:0~64
// ??X Y????128 64??????????????????????
// size:?????С
// mode??1 ???????     0 ??????
//*p:?????????

#ifdef THE_ERROR_CODE
void OLED_ShowChineseX(uint8_t x, uint8_t y, const char *p, uint8_t size, uint8_t mode)
{
    uint8_t len = 0, i = 0, arr = 0;
    char chinese[3];
    len = strlen(p) / 3;

    for (i = 0; i < len; i++)
    {
        uint8_t a = 0;

        for (a = 0; a < 3; a++)
        {
            chinese[a] = p[arr];
            arr++;
        }

        if (arr == 0)
        {
            if (x > 128)
            {
                x = 0;
                y += size;
            }

            if (y > 64)
            {
                y = x = 0;
            }

            OLED_ShowChinese(x, y, chinese, size, mode);
            x += size;
            memset(chinese, 0, strlen(chinese));
        }
    }
}
#endif

void OLED_ShowChineseX(uint8_t x, uint8_t y, const char *p, uint8_t size, uint8_t mode) // "电阻\0“
{
    for (int i = 0; p[i] != '\0'; i += 3) // 当p指向的字符不是字符串结束符时
    {
        char tmp[4] = {p[i], p[i + 1], p[i + 2], '\0'};
        OLED_ShowChinese(x, y, tmp, size, mode); // 显示一个中文字符
        //x += size + 2;
        x += size;

    }
}

// С?????????
// ?????????????С??
// x:0~110
// y:0~52
// ??X Y????110 52??????????????????????????
// Z_len????????λ????X_len?С?????λ????size??????С
void OLED_Showdecimal(uint8_t x, uint8_t y, float num, uint8_t Z_len, uint8_t X_len, uint8_t size)
{
    uint8_t t, temp;
    uint8_t enshow;
    int z_temp, f_temp;
    z_temp = (int)num;

    // ????????
    for (t = 0; t < Z_len; t++)
    {
        temp = (z_temp / mypow(10, Z_len - t - 1)) % 10;

        if (enshow == 0 && t < (Z_len - 1))
        {
            if (temp == 0)
            {
                OLED_ShowChar(x + (size / 2) * t, y, ' ', size, 1);
                continue;
            }
            else
                enshow = 1;
        }

        OLED_ShowChar(x + (size / 2) * t, y, temp + '0', size, 1);
    }

    // С????
    OLED_ShowChar(x + (size / 2) * (Z_len), y, '.', size, 1);

    f_temp = (int)((num - z_temp) * (mypow(10, X_len)));

    // С??????
    for (t = 0; t < X_len; t++)
    {
        temp = (f_temp / mypow(10, X_len - t - 1)) % 10;
        OLED_ShowChar(x + (size / 2) * (t + Z_len) + 5, y, temp + '0', size, 1);
    }

    OLED_Refresh_Gram();
}

void OLED_ShowDouble(uint8_t x, uint8_t y, double num, uint8_t Z_len, uint8_t X_len, uint8_t size)
{
    char str[256];                     // 存储数字字符串
    sprintf(str, "%.*f", X_len, num); // 将数字转换为字符串，保留X_len位小数
    int len = strlen(str);             // 字符串长度
    int dot = strchr(str, '.') - str;  // 小数点位置
    int zlen = dot;                    // 整数部分长度
    int xlen = len - dot - 1;          // 小数部分长度

    if (Z_len > zlen) // 整数部分不足Z_len位，需要在前面补零
    {
        for (int i = len - 1; i >= 0; i--) // 将字符串后移Z_len - zlen位
        {
            str[i + Z_len - zlen] = str[i];
        }
        for (int i = 0; i < Z_len - zlen; i++) // 在前面补零
        {
            str[i] = '0';
        }
        len += Z_len - zlen; // 更新字符串长度
        dot += Z_len - zlen; // 更新小数点位置
    }
    else if (Z_len < zlen) // 整数部分超过Z_len位，需要截断
    {
        for (int i = 0; i < len - zlen + Z_len; i++) // 将字符串前移zlen - Z_len位
        {
            str[i] = str[i + zlen - Z_len];
        }
        len -= zlen - Z_len; // 更新字符串长度
        dot -= zlen - Z_len; // 更新小数点位置
    }

    if (X_len > xlen) // 小数部分不足X_len位，需要在后面补零
    {
        for (int i = len; i < len + X_len - xlen; i++) // 在后面补零
        {
            str[i] = '0';
        }
        len += X_len - xlen; // 更新字符串长度
    }
    else if (X_len < xlen) // 小数部分超过X_len位，需要截断
    {
        len -= xlen - X_len; // 更新字符串长度
    }

    str[len] = '\0'; // 字符串结束符

    for (int i = 0; i < len; i++) // 逐个显示每个字符
    {
        OLED_ShowChar(x + i * size / 2, y, str[i], size, 1);
    }

    OLED_Refresh_Gram();
}

// OLED???????
void OLED_BrightnessSet(uint8_t V)
{
    // ????OLED????
    OLED_Write(0xAE, OLED_CMD); // ??????
    OLED_Write(0xD5, OLED_CMD); // ?????????????,?????
    OLED_Write(0x80, OLED_CMD); //[3:0],???????;[7:4],?????
    OLED_Write(0xA8, OLED_CMD); // ???????????
    OLED_Write(0X3F, OLED_CMD); // ???0X3F(1/64)
    OLED_Write(0xD3, OLED_CMD); // ??????????
    OLED_Write(0X00, OLED_CMD); // ????0
    OLED_Write(0x40, OLED_CMD); // ???????????? [5:0],????.
    OLED_Write(0x8D, OLED_CMD); // ????????
    OLED_Write(0x14, OLED_CMD); // bit2??????/???
    OLED_Write(0x20, OLED_CMD); // ???????????
    OLED_Write(0x02, OLED_CMD); //[1:0],00???е????;01???е????;10,??????;???10;
    OLED_Write(0xA1, OLED_CMD); // ???????????,bit0:0,0->0;1,0->127;
    OLED_Write(0xC0, OLED_CMD); // ????COM??跽??;bit3:0,?????;1,??????? COM[N-1]->COM0;N:???????
    OLED_Write(0xDA, OLED_CMD); // ????COM???????????
    OLED_Write(0x12, OLED_CMD); //[5:4]????
    OLED_Write(0x81, OLED_CMD); // ????????
    OLED_Write(V, OLED_CMD);    // 1~255;???0X7F (????????,??????)
    OLED_Write(0xD9, OLED_CMD); // ????????????
    OLED_Write(0xf1, OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2;
    OLED_Write(0xDB, OLED_CMD); // ????VCOMH ???????
    OLED_Write(0x30, OLED_CMD); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;
    OLED_Write(0xA4, OLED_CMD); // ??????????;bit0:1,????;0,???;(????/????)
    OLED_Write(0xA6, OLED_CMD); // ??????????;bit0:1,???????;0,???????
    OLED_Write(0xAF, OLED_CMD); // ???????
}

/**
 * @brief       OLED?????
 * @param       ??????x  : 0~127
 * @param       y  : 0~63
 * @param       ???????width  : 0~127
 * @param       ?????height  : 0~63
 * @param       *pic  : ??????????
 * @param       mode: 1 ??????? 0,???????
 */
void OLED_Show_Picture(uint8_t x, uint8_t y, uint8_t width, uint8_t height, const uint8_t *pic, uint8_t mode)
{
    uint8_t temp, j;
    uint8_t y0 = y;
    uint8_t *g_pic = NULL;
    uint16_t i, psize = 0;

    /* ???????????????? */
    psize = (height / 8 + ((height % 8) ? 1 : 0)) * width;

    /* ??????Χ ?????? */
    if ((x + width > 128) || (y + height > 64))
        return;

    g_pic = (uint8_t *)pic;

    for (i = 0; i < psize; i++)
    {
        temp = g_pic[i];

        for (j = 0; j < 8; j++) /* ?????????е?8??λ????????ж? */
        {
            if (temp & 0x80) /* ??λ??????????? */
            {
                OLED_DrawPoint(x, y, mode);
            }
            else
            {
                OLED_DrawPoint(x, y, !mode);
            }

            temp <<= 1;
            y++;

            if ((y - y0) == height) /* ????????????????? */
            {
                y = y0;
                x++;
                break;
            }
        }
    }

    OLED_Refresh_Gram(); // ?????????OLED??????????????????????
}

void OLED_Moveleft(void) // ????
{
    OLED_Write(0x2E, OLED_CMD); // ??????
    OLED_Write(0x27, OLED_CMD);
    OLED_Write(0x00, OLED_CMD); // ???????
    OLED_Write(0x00, OLED_CMD); // ????
    OLED_Write(0X07, OLED_CMD); // ??????
    OLED_Write(0x07, OLED_CMD); // ??????
    OLED_Write(0X00, OLED_CMD); // ???????
    OLED_Write(0xFF, OLED_CMD); // ????????
    OLED_Write(0x2F, OLED_CMD); // ????????
}

void OLED_Moveright(void) // ????
{
    OLED_Write(0x2E, OLED_CMD); // ??????
    OLED_Write(0x26, OLED_CMD);
    OLED_Write(0x00, OLED_CMD); // ???????
    OLED_Write(0x00, OLED_CMD); // ????
    OLED_Write(0X07, OLED_CMD); // ??????
    OLED_Write(0x07, OLED_CMD); // ??????
    OLED_Write(0X00, OLED_CMD); // ???????
    OLED_Write(0xFF, OLED_CMD); // ????????
    OLED_Write(0x2F, OLED_CMD); // ????????
}
